# React Router v7 + TypeScript + Tailwind CSS v4 - Project Rules

You are an expert in React Router v7, TypeScript, Tailwind CSS v4, and modern React development patterns.

## üèóÔ∏è PROJECT ARCHITECTURE

### Feature-First Organization

- Use **Feature-First Architecture** - each feature is self-contained in its own folder
- Structure: `app/modules/{module}/{feature}/`
- Each feature contains ALL related code: components, hooks, types, utils, stores
- Shared code goes to `app/shared/` only when used by 2+ features
- Use barrel exports (`index.ts`) for clean imports

### Module Structure Pattern

```
module-name/
‚îú‚îÄ‚îÄ module-store.ts             # State management (Zustand)
‚îú‚îÄ‚îÄ module-types.ts             # TypeScript types
‚îú‚îÄ‚îÄ use-module.ts               # Custom hooks
‚îú‚îÄ‚îÄ module.service.ts           # API services (if needed)
‚îú‚îÄ‚îÄ sub-feature/                # Sub-features (if needed)
‚îÇ   ‚îú‚îÄ‚îÄ sub-feature-page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îî‚îÄ‚îÄ index.ts                    # Barrel exports
```

### Naming Conventions

- **Folders**: `kebab-case` (`auth/`, `user-profile/`, `product-list/`)
- **Files**:
  - Store files: `{module}-store.ts` (e.g., `auth-store.ts`, `user-store.ts`)
  - Type files: `{module}-types.ts` (e.g., `auth-types.ts`, `user-types.ts`)
  - Hook files: `use-{feature}.ts` (e.g., `use-auth.ts`, `use-user-profile.ts`)
  - Service files: `{module}.service.ts` (e.g., `auth.service.ts`)
  - Page components: `{feature}-page.tsx` (e.g., `login-page.tsx`)
- **Components**: `PascalCase` (`LoginPage`, `ProductCard`)
- **Functions**: `camelCase` (`useAuth`, `formatPrice`)
- **Constants**: `UPPER_SNAKE_CASE` (`API_ENDPOINTS`)

## üõ†Ô∏è TECHNOLOGY STACK

### Core Framework

- **React Router v7** with file-based routing
- **React 19** with functional components only (no class components)
- **TypeScript** in strict mode
- **Vite** as build tool
- **pnpm** as package manager

### Key Dependencies

- `@react-router/dev` - React Router v7
- `zustand` - State management
- `tailwindcss@4` - Styling with CSS variables
- `tailwind-variants` - Component styling patterns
- `axios` - HTTP client
- `lucide-react` - Icons

## üé® DESIGN SYSTEM & COLOR TOKENS

### ‚ö†Ô∏è CRITICAL: Always Use Design System Color Tokens

**NEVER use hardcoded colors or Tailwind's default colors. ALWAYS use the configured color tokens from the design system.**

### How to Find Available Color Tokens

When building UI components, **ALWAYS check the design system files first** to see what color tokens are available:

1. **Check the main design system file**: `app/shared/styles/app.css`
   - Look for `@theme` section to see all available color tokens
   - Each token follows the pattern: `--color-{name}`

2. **Check theme files for actual values**:
   - `app/shared/styles/light.css` - Light theme color values
   - `app/shared/styles/dark.css` - Dark theme color values

3. **Use Tailwind classes** that correspond to the CSS variables:
   - CSS variable: `--color-primary` ‚Üí Tailwind class: `bg-primary`, `text-primary`
   - CSS variable: `--color-primary-foreground` ‚Üí Tailwind class: `text-primary-foreground`
   - CSS variable: `--color-primary-muted` ‚Üí Tailwind class: `bg-primary-muted`

### Color Token Naming Patterns

The design system follows these naming patterns:

#### Base Colors

- `background` - Main background color
- `foreground` - Main text color
- `muted` - Muted background color
- `muted-foreground` - Muted text color
- `border` - Border color
- `ring` - Focus ring color

#### Semantic Colors (with variants)

Each semantic color typically has these variants:

- `{color}` - Base color (e.g., `primary`, `success`, `error`)
- `{color}-foreground` - Text color on base background
- `{color}-focus` - Focus/hover state
- `{color}-muted` - Subtle background variant
- `{color}-subtle` - Very subtle background variant

### Color Usage Guidelines

#### ‚úÖ CORRECT - Use Design System Tokens

```tsx
// Text colors - Use semantic tokens from design system
className = "text-foreground"; // Main text
className = "text-muted-foreground"; // Secondary text
className = "text-primary"; // Primary brand color
className = "text-error"; // Error states
className = "text-success"; // Success states

// Background colors - Use semantic tokens from design system
className = "bg-background"; // Main background
className = "bg-muted"; // Muted background
className = "bg-primary"; // Primary background
className = "bg-error-muted"; // Error background (subtle)
className = "bg-success-muted"; // Success background (subtle)

// Border colors - Use semantic tokens from design system
className = "border-border"; // Default borders
className = "border-primary"; // Primary borders
className = "border-error"; // Error borders

// Hover states - Use focus variants from design system
className = "hover:bg-primary-focus"; // Primary hover
className = "hover:text-primary-focus"; // Primary text hover
className = "hover:bg-muted"; // Subtle hover
```

#### ‚ùå WRONG - Never Use These

```tsx
// Hardcoded colors - NEVER USE
className = "text-gray-900";
className = "text-blue-600";
className = "bg-red-50";
className = "border-gray-200";
className = "text-white";
className = "bg-black";

// Hex colors - NEVER USE
className = "text-[#000000]";
className = "bg-[#ffffff]";
className = "border-[#e5e7eb]";

// RGB colors - NEVER USE
className = "text-[rgb(0,0,0)]";
className = "bg-[rgba(255,255,255,0.8)]";
```

### Color Token Selection Strategy

When building UI components, follow this decision tree:

#### 1. Check Design System First

- **Always start** by looking at `app/shared/styles/app.css` to see available tokens
- **Check theme files** to understand the color values
- **Use the tokens** that are actually defined in the system

#### 2. Choose Appropriate Token Type

- **Base tokens**: Use for fundamental UI elements (`background`, `foreground`, `border`)
- **Semantic tokens**: Use for specific meanings (`primary`, `success`, `error`, `warning`, `info`)
- **Variant tokens**: Use for different states (`muted`, `focus`, `subtle`)

#### 3. Apply Consistent Patterns

- **Text**: Use `text-{token}` or `text-{token}-foreground`
- **Background**: Use `bg-{token}` or `bg-{token}-muted`
- **Borders**: Use `border-{token}`
- **Hover/Focus**: Use `hover:bg-{token}-focus` or `hover:text-{token}-focus`

### Component-Specific Patterns

```tsx
// Buttons - Use semantic color props
<Button color="primary" />           // Uses design system primary colors
<Button color="error" />             // Uses design system error colors
<Button variant="outlined" />        // Uses design system border colors

// Cards - Use base design system colors
<Card />                             // Uses bg-background text-foreground
<Card border="error" />              // Uses border-error-muted

// Inputs - Use design system focus states
<Input />                            // Uses border-border focus:border-primary
<Input invalid />                    // Uses border-error bg-error-muted
```

### Theme Support

All color tokens automatically adapt to light/dark themes. The tokens are defined in:

- `app/shared/styles/light.css` - Light theme values
- `app/shared/styles/dark.css` - Dark theme values
- `app/shared/styles/app.css` - Token definitions

**Always check these files when you need to understand the current color system.**

## üé® STYLING & UI

### Tailwind CSS v4 Conventions

- Use **Tailwind classes** that correspond to design system tokens
- Prefer **flat colors** over gradients
- All buttons must have **transitions**
- Follow Tailwind v4 naming conventions for all className values
- Use responsive design with mobile-first approach

### Component Styling

- Use `tailwind-variants` (tv) for complex component styling patterns
- Use `cn()` helper function for className concatenation (not react-tvcx)
- Component structure: base styles + variants + compound variants
- Always use design system color tokens in variants

### Design System

- Consistent sizing: `xs`, `sm`, `md`, `lg` variants
- Color system: Use semantic color tokens (primary, success, error, warning, info, accent)
- Shape variants: `normal`, `pill`, `circle`, `square`
- Component variants: `default`, `outlined`, `ghost`, `light`

## üì¶ STATE MANAGEMENT

### Zustand Patterns

- Use `create()` with TypeScript generics
- Implement `persist` middleware for auth and user data
- Include loading and error states for async actions
- Use `createJSONStorage(() => localStorage)` for persistence
- Actions should be async/await with proper error handling

### Store Structure

```typescript
interface StoreState {
  // Data
  data: T | null;
  // UI States
  isLoading: boolean;
  error: string | null;
  // Actions
  actionName: (params) => Promise<void>;
  clearError: () => void;
}
```

### Store Location

- **Feature-specific stores** ‚Üí `app/modules/{module}/{module}-store.ts`
- **Global stores** ‚Üí `app/shared/stores/` (only if truly global)

## üîß COMPONENT PATTERNS

### React Patterns

- **Functional components only** - no class components
- Use `forwardRef` for reusable components
- Implement proper TypeScript props interfaces
- Use custom hooks for feature-specific logic
- Follow compound component patterns for complex UI

### Component File Structure

```
feature-name/
‚îú‚îÄ‚îÄ feature-page.tsx        # Main page component
‚îú‚îÄ‚îÄ feature-component.tsx   # Sub-components
‚îú‚îÄ‚îÄ use-feature.ts         # Custom hooks
‚îú‚îÄ‚îÄ feature-types.ts       # Types
‚îú‚îÄ‚îÄ feature-utils.ts       # Utilities
‚îî‚îÄ‚îÄ index.ts              # Barrel exports
```

### Props & Types

- Use `interface` for component props
- Extend HTML element props when appropriate
- Use `React.ComponentProps<'element'>` for base element props
- Implement proper `forwardRef` typing

## üìÅ FILE ORGANIZATION

### Import Order (auto-organized by Prettier)

```typescript
// 1. React imports
import { useState, useEffect } from "react";

// 2. External library imports
import { create } from "zustand";

// 3. Module imports (~/modules)
import { useAuth } from "~/modules/auth";
import { useUserProfile } from "~/modules/user";

// 4. Shared imports (~/shared)
import { Button } from "~/shared/components";
import { cn } from "~/shared/utils";

// 5. Type imports
import type { AuthCredentials } from "~/modules/auth";
```

### Path Aliases

- Use `~/` for all internal imports (`./app/`)
- Avoid relative imports (`../../`)
- Configure in `tsconfig.json` paths

### Export Patterns

- Use **named exports** (avoid default exports except for pages)
- Implement barrel exports via `index.ts`
- Export types separately: `export type { TypeName }`

## üí¨ COMMENTING GUIDELINES

### Comment Rules

- **Use ONLY English comments** - no Vietnamese or other languages
- **Minimize comments** - prefer self-documenting code
- **Only comment when necessary** - when logic is complex or non-obvious
- **Use JSDoc for public APIs** - functions, components, and types that are exported
- **Avoid obvious comments** - don't comment what the code clearly shows

### When to Comment

```typescript
// ‚úÖ Good - complex business logic
const calculateDiscount = (price: number, userType: UserType) => {
  // Apply tiered discount based on user type and purchase history
  const baseDiscount = userType === "premium" ? 0.15 : 0.05;
  const loyaltyBonus = getUserLoyaltyBonus(userId);
  return price * (baseDiscount + loyaltyBonus);
};

// ‚ùå Bad - obvious comment
const user = getUser(); // Get user

// ‚úÖ Good - JSDoc for public API
/**
 * Authenticates user with provided credentials
 * @param credentials - User login credentials
 * @returns Promise resolving to auth result
 */
export const authenticateUser = async (credentials: AuthCredentials) => {
  // Implementation
};
```

### Comment Style

- Use `//` for single-line comments
- Use `/* */` for multi-line comments only when necessary
- Use JSDoc `/** */` for public APIs and complex functions
- Keep comments concise and focused on the "why" not the "what"

## üöÄ DEVELOPMENT PRACTICES

### Code Quality

- Follow ESLint configuration (relaxed but strict)
- Use Prettier with minimal configuration (only non-default values)
- Implement TypeScript strict mode
- Write descriptive variable and function names

### Error Handling

- Use try-catch blocks for async operations
- Implement proper error states in components
- Use React Error Boundaries for fallbacks
- Show user-friendly error messages

### Performance

- Use React.memo() for expensive components
- Implement proper dependency arrays in hooks
- Use code splitting at route level
- Optimize bundle size with tree shaking

## üéØ ROUTING PATTERNS

### React Router v7 File-based Routing

```typescript
// app/routes.ts - Central configuration
export default [
  index("modules/home/home-page/home-page.tsx"),
  route("dashboard", "modules/dashboard/dashboard-page.tsx"),
  route("products", "modules/products/product-list-page.tsx"),
] satisfies RouteConfig;
```

### Page Components

- Export as default function
- Use descriptive names: `LoginPage`, `ProductListPage`
- Implement proper meta data and SEO
- Handle loading and error states

## üìã TYPESCRIPT CONVENTIONS

### Type Organization

- Feature-specific types in feature folders (`app/modules/{module}/{module}-types.ts`)
- Shared types in `app/shared/types/` (only if used by 2+ features)
- Use `interface` for object shapes
- Use `type` for unions and computed types

### Naming

- Interfaces: `PascalCase` (`User`, `AuthCredentials`)
- Types: `PascalCase` with descriptive suffixes (`UserRole`, `ApiResponse`)
- Generics: Single letter or descriptive (`T`, `TData`)

## üîí SECURITY & API

### Authentication Patterns

- JWT tokens with refresh mechanism
- Persistent auth state with Zustand
- Protected routes with proper guards
- Secure token storage in localStorage

### API Integration

- Use Axios with base client configuration (`app/shared/api/base-client.ts`)
- Implement proper error handling
- Use TypeScript for request/response types
- Handle loading states consistently

## üöÄ GIT & DEVELOPMENT

### Commit Conventions

- Start commit messages with rocket emoji: üöÄ
- Use clear, descriptive commit messages
- Follow conventional commits when possible

### Scripts & Commands

- Use `pnpm` for all package management
- Available scripts: `dev`, `build`, `typecheck`, `lint`, `format`
- Run `pnpm check` before commits

## üìù CODING BEST PRACTICES

### Component Development

1. Start with page component
2. Add feature-specific sub-components
3. Extract custom hooks for logic
4. Add types and utilities as needed
5. Implement clean exports via index.ts

### Code Style

- Use arrow functions for components and handlers
- Implement proper TypeScript typing
- Follow single responsibility principle
- Keep components focused and small
- Use descriptive prop and variable names

### Color Token Best Practices

#### ‚úÖ DO - Always Use Design System Tokens

```tsx
// ‚úÖ Correct - Uses semantic color tokens from design system
<div className="bg-background text-foreground border border-border">
  <h1 className="text-foreground">Title</h1>
  <p className="text-muted-foreground">Description</p>
  <Button color="primary">Action</Button>
  <span className="text-error">Error message</span>
</div>
```

#### ‚ùå DON'T - Never Use Hardcoded Colors

```tsx
// ‚ùå Wrong - Uses hardcoded colors instead of design system tokens
<div className="bg-white text-black border border-gray-200">
  <h1 className="text-gray-900">Title</h1>
  <p className="text-gray-600">Description</p>
  <button className="bg-blue-600 text-white">Action</button>
  <span className="text-red-600">Error message</span>
</div>
```

#### Color Token Selection Process

When building UI components, follow this process:

1. **Check Design System First**: Look at `app/shared/styles/app.css` to see available tokens
2. **Choose Base vs Semantic**:
   - Use base tokens (`foreground`, `background`, `border`) for fundamental elements
   - Use semantic tokens (`primary`, `success`, `error`) for specific meanings
3. **Select Appropriate Variant**:
   - Base: `text-{token}`, `bg-{token}`, `border-{token}`
   - Foreground: `text-{token}-foreground` for text on colored backgrounds
   - Muted: `bg-{token}-muted` for subtle backgrounds
   - Focus: `hover:bg-{token}-focus` for interactive states
4. **Verify Token Exists**: Ensure the token is actually defined in the design system
5. **Test Theme Support**: Verify it works in both light and dark themes

### Testing Strategy

- Write component tests for critical features
- Test custom hooks thoroughly
- Implement integration tests for user flows
- Use proper TypeScript in tests

## üé® UI/UX PATTERNS

### Consistent UI Elements

- Use shared components from `~/shared/components`
- Implement consistent spacing and typography
- **ALWAYS use design system color tokens** - never hardcoded colors
- Ensure responsive design across all screens

### Color Token Usage in UI Patterns

#### Status Indicators

Use semantic color tokens for different states. Check the design system for available semantic colors:

```tsx
// Success states - Use success tokens from design system
<div className="bg-success-muted text-success">Operation completed successfully</div>

// Error states - Use error tokens from design system
<div className="bg-error-muted text-error">Something went wrong</div>

// Warning states - Use warning tokens from design system
<div className="bg-warning-muted text-warning">Please review your input</div>

// Info states - Use info tokens from design system
<div className="bg-info-muted text-info">New feature available</div>
```

#### Interactive Elements

Use semantic color props and design system tokens:

```tsx
// Primary actions - Use semantic color props
<Button color="primary">Save Changes</Button>

// Secondary actions - Use outlined variant with design system colors
<Button variant="outlined">Cancel</Button>

// Destructive actions - Use semantic error color
<Button color="error">Delete</Button>

// Links - Use primary color with focus state
<a className="text-primary hover:text-primary-focus">Learn more</a>
```

#### Form Elements

Use base and semantic tokens from design system:

```tsx
// Labels - Use foreground color from design system
<label className="text-foreground font-medium">Email Address</label>

// Placeholders - Use muted foreground from design system
<input placeholder="Enter your email" className="placeholder:text-muted-foreground" />

// Validation errors - Use error token from design system
<span className="text-error text-sm">Email is required</span>

// Success feedback - Use success token from design system
<span className="text-success text-sm">Email sent successfully</span>
```

#### Layout & Structure

Use base design system tokens for layout elements:

```tsx
// Main content areas - Use background and foreground tokens
<main className="bg-background text-foreground">

// Sidebars/navigation - Use muted background and border tokens
<nav className="bg-muted border-border">

// Cards/containers - Use background and border tokens
<div className="bg-background border border-border">

// Dividers - Use border token from design system
<hr className="border-border" />
```

### Loading & Error States

- Show loading indicators for async operations
- Implement proper error boundaries
- Display user-friendly error messages using `text-error` and `bg-error-muted`
- Handle empty states gracefully with `text-muted-foreground`

### Empty States

```tsx
// Empty state with muted colors
<div className="text-center py-8">
  <div className="text-muted-foreground text-lg">No items found</div>
  <p className="text-muted-foreground mt-2">
    Try adjusting your search criteria
  </p>
  <Button color="primary" className="mt-4">
    Add New Item
  </Button>
</div>
```

## üîÑ MODULE ORGANIZATION

### When to Use Modules vs Shared

```typescript
// ‚úÖ Module-specific (feature folder)
- State management for the feature
- Custom hooks for the feature
- Types specific to the feature
- API services for the feature
- Components only used by the feature

// ‚úÖ Shared (shared folder)
- UI components used across features
- Utility functions used across features
- Global state management
- Layout components
- API client and configuration
```

### Creating New Features

1. **Create module folder**: `app/modules/new-feature/`
2. **Add core files**:
   - `new-feature-store.ts` (if state needed)
   - `new-feature-types.ts` (if types needed)
   - `use-new-feature.ts` (if hooks needed)
   - `new-feature.service.ts` (if API needed)
3. **Add sub-features** (if needed): `app/modules/new-feature/sub-feature/`
4. **Export everything** in `index.ts`
5. **Update main modules index**: `app/modules/index.ts`

### Import Patterns

```typescript
// ‚úÖ Feature-specific imports
import { useAuth } from "~/modules/auth";
import { useUserProfile } from "~/modules/user";

// ‚úÖ Shared imports
import { Button } from "~/shared/components";
import { useLocalStorage } from "~/shared/hooks";
import { cn } from "~/shared/utils";

// ‚úÖ Type imports
import type { AuthCredentials } from "~/modules/auth";
import type { UserProfile } from "~/modules/user";
```

## üéØ CRITICAL REMINDERS

### Color Token Priority

**ALWAYS prioritize design system color tokens over any other color approach:**

1. **First choice**: Use semantic color tokens from the design system (check `app/shared/styles/app.css`)
2. **Second choice**: Use base color tokens from the design system (`foreground`, `background`, `border`)
3. **Never use**: Hardcoded colors, hex values, RGB values, or Tailwind's default colors

### Design System Discovery Process

**Before using any colors, always:**

1. **Check the design system file**: `app/shared/styles/app.css`
   - Look for `@theme` section to see all available tokens
   - Understand the naming patterns: `--color-{name}`

2. **Check theme files**:
   - `app/shared/styles/light.css` - Light theme values
   - `app/shared/styles/dark.css` - Dark theme values

3. **Use Tailwind classes** that correspond to CSS variables:
   - `--color-primary` ‚Üí `bg-primary`, `text-primary`
   - `--color-primary-foreground` ‚Üí `text-primary-foreground`
   - `--color-primary-muted` ‚Üí `bg-primary-muted`

### Naming Pattern Reference

- **Base tokens**: `background`, `foreground`, `muted`, `muted-foreground`, `border`, `ring`
- **Semantic tokens**: `primary`, `success`, `error`, `warning`, `info`, `accent` (check design system for full list)
- **Variants**: `{token}`, `{token}-foreground`, `{token}-focus`, `{token}-muted`, `{token}-subtle`

### Quick Decision Guide

When choosing colors, ask yourself:

- **Is this a fundamental UI element?** ‚Üí Use base tokens (`background`, `foreground`, `border`)
- **Does this have a specific meaning?** ‚Üí Use semantic tokens (`primary`, `success`, `error`)
- **Do I need a subtle variant?** ‚Üí Use muted variants (`bg-primary-muted`, `text-muted-foreground`)
- **Is this interactive?** ‚Üí Use focus variants (`hover:bg-primary-focus`)

Remember: This project prioritizes **developer experience**, **maintainability**, and **scalability** through consistent patterns and conventions. Each feature is self-contained with all its related code, and the shared folder only contains truly global utilities and components. Use minimal, English-only comments and prefer self-documenting code.

**Most importantly: ALWAYS check the design system files first - NEVER use hardcoded colors!**
